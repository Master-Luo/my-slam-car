基本想法：

先从一个基本框架搭起，再去扩展它的功能，不会搭建的部分暂时加上注释就行，把可以做的部分做了再查资料，看人家这部分怎么写的，回来再补上


1.先创建一个功能包，里面包含3个node,都具有publish和subscribe的功能框架，frentend_node,backend_node,map_node，;

//因为camera有realsense的包，可以直接发布topic,相当于写好了node,所以只需要写3个
//会用到帧，特征，路标点这样的数据结构，把它们封装成类，它们包含了声明的头文件放在功能包里的include文件夹下，对成员函数在类外定义在同名cpp文件里，cpp放在功能包里的src下,为了避免由于交叉引用在编译时带来的重复定义问题，将这些cpp文件链接为一个库
//

//但是VO内部初始化的logic,
//之前的理解应该有问题，初始化应该是对整个系统的，换而言之，应该包括
//相机参数的初始化，文件路径的配置，前端节点的建立，相应容器数据结构类型的声明

//如果是第一帧，则初始化？？？怎么实现的，其中配置的机制是什么
//要干什么: 初始化/外参标定/SFM
//当说初始化时，是对整个系统初始化，而不止是某一部分；所以应该封装

//首先设置parameter,创建一个fronted对象(创建一个前端)
//再创建一个frame,给它图像(img_callback)，
//frontend去add这个frame，判断状态，进行对应处理
//所以这里对系统初始化封装为库函数直接用逻辑上并不直观，VO写成一个节点用回调
//addframe调用一个大track()函数，其中包含了tracklastframe成员函数
//完成feature和pose计算后，再判断是否insertkeyframe()，并执行(右目提取+三角化)
//其实track()还是对大部分功能进行了封装，再把它放入img_callback中
///1.2.提取特征点 -》前端成员函数DetectFeatures()提取GFFT特征，封装到一个feature对象中
 //2.光流追踪 -》 调用LK光流，传入两帧图像和一帧特征点，得到当前帧特征点，封装到feature中
 //3.位姿估计 -》这部分无法调用，要写(自己写或别人写的)，pose放入frame中，//定位
 //4.判断是否为关键帧 -》bool is_keyframe_ ,由特征点数量判断，如果不是关键帧，就回到1，
 //-》是关键帧，进入5
 //5.关键帧三角化 -》对左目提取特征点，进行(1.2+2)的操作完成双目匹配，为了保证同步，一般
 //在1会同时接收左右目，匹配后得到右目，再进行三角化，得到特征点空间坐标，封装到mappoint中
 //这部分可以调用，也可以写；

//6.发布topic给map_node,和rviz
//6.发布关键帧topic-> 消息类型是什么样的？需要的是"当前frame的pose"和"mappoint";

 ///7.map_node ->持有keyframe的pose 和mappoint,对关键帧保持一个滑动窗口，控制规模 
 ///应该主要是为后端提供一些服务，如果暂时没有后端，可以先不用



2.frentend_node的分析


frentend_node应该具备什么功能： 单目定位

初始化（处理第一帧，或追踪丢失）
提取特征点 -> 光流处理 -> 位姿估算 -> 判断关键帧，如果不是关键帧，则进行下一次光流处理；如果判断为关键帧，则提取新特征，

///////////////////////////////////////////////////////暂时不加左右匹配，三角化（获得特征点的空间坐标，形成landmark)

frentend_node的数据结构：
定义一个img_callback函数，接受图像信息，
其中光流处理需要接受camera的图像信息，所以放在callback函数中去接受topic(类型为图像信息），得到特征点，再对上一帧图像信息进行track匹配，得到位姿变换的估计,；
由追踪的特征点数，判断是否应该为关键帧，如果是，则发布topic(类型为对关键帧的引用/指针，其中包含了位姿和观测的路标点，由于指针是一个地址，也许？可以用字符类型去表达topic，具体可以看一下vinsmono?A-loam?）

关于双目的一些想法：
//1.先将img封装入frame::ptr这样一个数据结构中
//14讲读取图片那里是用imread读地址给Mat，再把图片传给frame
 //mono里是单目，这里要用双目，所以订阅两个topic，然后用同步器同步回调函数
//要在配置文件中提前设置双目模式 https://blog.csdn.net/qq_35942419/article/details/117021767

//因为是双目，所以左右目各对应一个topic,右目回调(右目提取+三角化)
    //这里要先改launch文件的设置见参考文件，然后在ros中检查一遍话题名大概应该是下面这样
    ///camera/infra1/image_rect_raw 4 /left_cam
    ///camera/infra2/image_rect_raw 4 /right_cam

    //这里应该使用多消息同步回调，就只需要写一个回调函数
      /*路标点也可以用point发布geometry_msgs::Point
    ros::Publisher  pub_point = n.advertise<sensor_msgs::PointCloud>("mappoint",1000);
    */

//7.循环，这里有几种写法可以直接加while,如果是数据集一般用for遍历所有图片
//但是在ros中由于回调函数这个神奇的存在，就不需要写循环了
//topic一直发布，回调函数就自动执行，所有操作都封装在里面，自动循环了


/////////////////////////////////暂时只写前端看看///////////////////////////////////////////////
3.backend_node

建立了一个长度为5的滑动窗口，订阅包含关键帧信息的topic，优化位姿和路标点，发布包含优化后的关键帧信息的topic,



4.map_node

订阅frentend_node发布的topic,实时显示位姿，也订阅backend_node发布的topic,更新优化后的位姿和路标点








